<p align="center">
<a href="https://mp.weixin.qq.com/s/QVF6upVMSbgvZy8lHZS3CQ" target="_blank">
  <img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210924105952.png" width="1000"/>
</a>
<p align="center"><strong><a href="https://mp.weixin.qq.com/s/tqCxrMEU-ajQumL1i8im9A">参与本项目</a>，贡献其他语言版本的代码，拥抱开源，让更多学习算法的小伙伴们收益！</strong></p>

## 96.不同的二叉搜索树

[力扣题目链接](https://leetcode-cn.com/problems/unique-binary-search-trees/)

给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

示例:

![](https://img-blog.csdnimg.cn/20210113161941835.png)

## 思路

这道题目描述很简短，但估计大部分同学看完都是懵懵的状态，这得怎么统计呢？

关于什么是二叉搜索树，我们之前在讲解二叉树专题的时候已经详细讲解过了，也可以看看这篇[二叉树：二叉搜索树登场！](https://programmercarl.com/0700.二叉搜索树中的搜索.html)在回顾一波。

这道题的核心思想就是，**==对于一个dp来说，这个dp并不是指具体的数字，而是指一堆连续的数字可以排列出的树的个数==**
光看描述不好理解，举个例子，dp[5]指的就是5个连续数字可以组成的二叉搜索树的个数
这5个数字不一定是[1,2,3,4,5]，也可以是[7,8,9,10,11]，只要是i个连续的数，就一定可以排列出dp[i]个二叉搜索树

理解完这个做题就没压力了

- 首先dp[0] = 1

- dp[1]时，只有一个数，那dp[1] = 1

- dp[2]时，有两个数，只有两种排列，那么dp[2] = 2

- dp[3]时，开始复杂一些了，可以是1,2,3作为根节点

  - 如果1作为根节点，那么23只能放在其右边，因为是两个连续的数，所以可以排成的二叉搜索树为dp[2]

  - 如果2作为根节点，那么1和3各放在其左右边，因为是一个数，所以可排成的二叉搜索树为dp[1] * dp[1]

  - 如果3作为根节点，那么12只能放在其左边，同上，此时为dp[2]

    所以dp[3] = dp[2] * 2 + dp[1]

观察一下就能总结出规律

- 比如[1,2,3,4,5,6] 此时需要求出dp[6]

- 首先看1和6，其左侧（右侧）无数字，为dp[0]，右侧（左侧）为5个连续的数，为dp[5]，则他们各自可以排成的树个数为dp[0] * dp[5]

- 2和5，可排成的树个数为dp[1] * dp[4]

- 3和4则为dp[2] * dp[3]

  那么dp[6] = sum(
  1:dp[0] * dp[5]
  2:dp[1] * dp[4]
  3:dp[2] * dp[3]
  4:dp[3] * dp[2]
  5:dp[4] * dp[1]
  6:dp[5] * dp[0]
  )




此时我们已经找到的递推关系了，那么可以用动规五部曲在系统分析一遍。

1. 确定dp数组（dp table）以及下标的含义

**dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]**。

也可以理解是i的不同元素节点组成的二叉搜索树的个数为dp[i] ，都是一样的。

以下分析如果想不清楚，就来回想一下dp[i]的定义

2. 确定递推公式

在上面的分析中，其实已经看出其递推关系， dp[i] += dp[左边j-1个数能够组成的二叉排序树数量] * dp[以右边i-j个连续数字组成的二叉排序树数量]

j是遍历i的元素，所以i：【1，i】

所以递推公式：dp[i] += dp[j-1] * dp[i - j ]

3. dp数组如何初始化

空树也是一个二叉排序树，所以dp[0] = 1

4. 确定遍历顺序

首先一定是遍历节点数，从递归公式：dp[i] += dp[j - 1] * dp[i - j]可以看出，节点数为i的状态是依靠 i之前节点数的状态。

那么遍历i里面每一个数作为头结点的状态，用j来遍历。

代码如下：

```CPP
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= i; j++) {
        dp[i] += dp[j - 1] * dp[i - j];
    }
}
```

5. 举例推导dp数组

n为5时候的dp数组状态如图：

![96.不同的二叉搜索树3](https://img-blog.csdnimg.cn/20210107093253987.png)

当然如果自己画图举例的话，基本举例到n为3就可以了，n为4的时候，画图已经比较麻烦了。

**我这里列到了n为5的情况，是为了方便大家 debug代码的时候，把dp数组打出来，看看哪里有问题**。

综上分析完毕，C++代码如下：

```java
class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;
        for(int i = 1; i <= n; i++){
            // 当前二叉排序树左边节点的个数
            for(int j = 1; j <= i; j++){
                dp[i] += dp[j-1] * dp[i - j];
            }
        }
        return dp[n];
    }
}
```

* 时间复杂度：$O(n^2)$
* 空间复杂度：$O(n)$

大家应该发现了，我们分析了这么多，最后代码却如此简单！

## 总结

这道题目虽然在力扣上标记是中等难度，但可以算是困难了！

首先这道题想到用动规的方法来解决，就不太好想，需要举例，画图，分析，才能找到递推的关系。

然后难点就是确定递推公式了，如果把递推公式想清楚了，遍历顺序和初始化，就是自然而然的事情了。

可以看出我依然还是用动规五部曲来进行分析，会把题目的方方面面都覆盖到！

**而且具体这五部分析是我自己平时总结的经验，找不出来第二个的，可能过一阵子 其他题解也会有动规五部曲了，哈哈**。

当时我在用动规五部曲讲解斐波那契的时候，一些录友和我反应，感觉讲复杂了。

其实当时我一直强调简单题是用来练习方法论的，并不能因为简单我就代码一甩，简单解释一下就完事了。

可能当时一些同学不理解，现在大家应该感受方法论的重要性了，加油💪




